#include <algorithm>
#include <cctype>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#include <bitset> // compact STL for

using namespace std;
typedef pair<int,int> ii;
typedef vector<int> vi;
typedef vector<ii> vii;
typedef set<int> si;
typedef set<ii> sii;
#define MP make_pair
#define PB push_back
#define TR(c,it) for( typeof(c.begin()) it = c.begin(); it != c.end(); ++it )
#define TRR(c,it) for( typeof(c.rbegin()) it = c.rbegin(); it != c.rend(); ++it)
#define REP(i,a) for (int i = 0; i < (a); i++)
#define FOR(i,a,b) for (int i = (a); i <= (b); i++)
#define FORD(i,a,b) for (int i = (a); i >= (b); i--)
inline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }

const int INF = 1<<29;
typedef long long int lli;
/*******************************************************/


lli _sieve_size; // ll is defined as:
bitset<47010> bs; // 10^7 + small //#include <bitset>
vi primes; // compact list of primes

void sieve(lli upperbound) { // create list of primes in [0 .. upperbound]
    _sieve_size = upperbound + 1; // add 1 to include upperbound
    bs.reset(); bs.flip(); // set all numbers to 1
    bs.set(0, false); bs.set(1, false); // except index 0 and 1
    for (lli i = 2; i <= _sieve_size; i++) if (bs.test((size_t)i)) {
    // cross out multiples of i starting from i * i!
    for (lli j = i * i; j <= _sieve_size; j += i) bs.set((size_t)j, false);
    primes.push_back((int)i); // also add this vector containing list of primes
}
} // call this method in main method

/*
bool isPrime(lli N) { // a good enough deterministic prime tester
if (N < _sieve_size) return bs.test(N); // O(1) for small primes
FOR (i, 0, primes.size() - 1) if (N % primes[i] == 0) return false;
return true; // it takes longer time if N is a large prime!
} // Note: only work for N <= (last prime in vi "primes")^2
*/


vi primeFactors(lli N) {
    vi factors;
    // vi "primes" (generated by sieve) is optional
    lli PF_idx = 0, PF = primes[PF_idx]; // using PF = 2, 3, 4, ..., is also ok.

    while (N != 1 && (PF * PF <= N)) { // stop at sqrt(N), but N can get smaller
        while (N % PF == 0) { N /= PF; factors.push_back(PF); } // remove this PF
        PF = primes[++PF_idx]; // only consider primes!
    }
    if (N != 1) factors.push_back(N); // special case if N is actually a prime
    return factors;
}

/*int EulerPhi(int N) {

    vi factors = primeFactors(N);
    vi::iterator new_end = unique(factors.begin(), factors.end()); // get unique
    int result = N;
    for (vi::iterator i = factors.begin(); i != new_end; i++)
        result = result - result / *i;
    return result;
}*/

int main() {
    int n;
    sieve(47000);// sgrt(2^31);


	while ( scanf("%d",&n) && n ){
        printf("%d = ",n);
        if (n < 0){ printf("-1 x "); n*= -1;}
        vi result = primeFactors(n);
        //unique(result.begin(), result.end()); // to remove duplicates
        printf("%d", *result.begin() );
        for (vi::iterator i = result.begin()+1; i != result.end(); i++)
            printf(" x %d",*i);
        printf("\n");

    };

  return 0;
}
