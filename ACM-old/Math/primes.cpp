#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <limits.h>
#include <map>
#include <queue>
#include <bitset>
#include <set>
#include <stack>
#include <string>
#include <vector>

using namespace std;
typedef pair<int,int> ii;
typedef vector<int> vi;
typedef vector<ii> vii;
typedef set<int> si;
typedef set<ii> sii;
#define MP make_pair
#define PB push_back
#define REP(i,a) for (int i = 0; i < int(a); i++)
#define FOR(i,a,b) for ( int i = int(a); i <= int(b); ++i )
#define FORS(i,a,b,s) for ( int i = int(a); i <= int(b);i+=s )
#define FORD(i,a,b) for ( int i = int(a); i >= int(b); --i )
#define TR(c,it) for( typeof(c.begin()) it = c.begin(); it != c.end(); ++it )
#define TRR(c,it) for( typeof(c.rbegin()) it = c.rbegin(); it != c.rend(); ++it )

const int INF = 1<<29;
typedef long long int lli;


const int MAXSIZE = 100000002;
vi primes;
bitset<MAXSIZE> bs;

/*
*  Nageneruje prvocisla do upperbound  vcetne
*  a ulozi je to vectoru primes
*  doba behu:
*   1M ~ 0.08 sec
*  10M ~ 0.75 sec
*  50M ~ 4 sec
*/
void ErathSieve( int upperbound ){
  int next;
  bs.set(0,true ); bs.set(1,true); //true - neni prvocislo
  primes.push_back(2);
  FORS(i,4,upperbound,2)
    bs.set(i,true); 
  FORS(i,3,upperbound,2)
    if ( bs[i] == false ) {
      primes.push_back(i);
      if ( i < 40000 /*MAX_INT_SQRT*/ )  
        FORS(j,i*i,upperbound, i)
          bs.set(j,true);
    }
}
/*
*  Otestuje zdali je dane cislo prvocislem
*  Doba behu 1-N:
*   1M ~ 0.210 sec
*   5M ~ 1.800 sec  
*  10M ~ 4.750 sec
*/
bool isPrime(unsigned int n){
  /*
  Pokus jsme generovali prvocisla, tk
  return !bs[n];
 */
  if ( n <= 1 ) return false;
  if ( n ==2 ) return true;
  if ( !(n%2) ) return false;
  for ( unsigned int i = 3; i*i <= n; i+=2) {
    if ( !(n%i) ) return false;
  } 
  return true;
}


//pokud mame nagenerovane pole prvocisel
void factorize(int n, vi & factors){
  factors.clear();
  // vi "primes" (generated by sieve) is optional
  int idx = 0; // index of first prime
  while (n != 1 && primes[idx] * primes[idx] <= n ) { // stop at sqrt(N), but N can get smaller
    if ( n % primes[idx] == 0) { 
      factors.push_back( primes[idx] );
      while (n % primes[idx] == 0) 
        n /= primes[idx]; 
    }
    idx++; // only consider primes!
  }
  if (n != 1) 
    factors.push_back(n); // special case if N is actually a prime
}  

//nemame pole prvocisel
void factorize2(int n, vi & factors) {
  factors.clear();
  int PF=3;
  if (!(n&1)) {
     factors.push_back(2);
     while (!(n&1)) n>>=1; 
  }
  while ( n!= 1 && PF*PF <=n ) {
    if ( n%PF == 0) { 
      factors.push_back( PF ); 
      while (n % PF == 0)
        n /= PF; 
    } 
    PF+=2; // only consider primes!
  }
  if (n != 1)  
    factors.push_back(n); // special case if N is actually a prime
}



//pokud mame uz predgenerovana prvocisla
int EulerPhi(int n){
  int res = n;
  int size = primes.size();
  if ( !bs[n] ) return n-1;
  for ( int i =0; i < size && primes[i]<=n; i++ )
    if ( !(n%primes[i]) )
      res = res- res/primes[i]; 
  return res;
}
//pokud nemam predgenerovana prvocisla
int EulerPhi2(int n){
  int res = n;
  vi factors;
  factorize2(n, factors);
  int size = factors.size();
  for ( int i = 0; i<size; i++)
    res = res - res/factors[i];
  return res;
}




void Print(){
  int n = primes.size();
  FOR(i,0,n-1)
    printf("%d ", primes[i]);
  printf("\n");
}

int main(){

  int n= 10000000;
  //ErathSieve(n);
  //printf("%d\n",EulerPhi2(2000000007));
  return 0;
}

