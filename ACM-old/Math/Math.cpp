
/** Kombinacne cislo **/

lli comb ( int a, int b){
    if (a < b) return 0;
    lli out = 1;

    if ( (a-b) > b )b = a-b;

    for ( int i = b+1; i <= a; i++) out *= i;
    for ( int i = a-b; i > 1; i--) out /= i;

    return   out;

}

/** Modularne kombinacne cislo!!! **/

/** | X ^ Y | mod MODUL **/

java BigInteger : x.modPow(y, n); // look ma, itâ€™s in the library ;)



lli squareAndMultiply( lli num, lli exp){ //skus ci normalne nasobenie nebude lepsie...
    lli temp = num;

    int j = 0;
    lli exp2 = exp;
    while (exp2 >>= 1) ++j; //diskretny logaritmus 2 exp.
    j--;

    for (j; j >= 0;  j--){

        temp *= temp;
        if (temp >= MODUL) temp%= MODUL;

        if ( (exp >> j) & 1 ){
            temp *= num;
            if (temp >= MODUL) temp%= MODUL;
        }
    }
    return temp;
}

/** goniometria**/

kosinova veta:

a^2 = b^2 + c^2 - 2bc * cos alfa
b^2 = c^2 + a^2 - 2ca * cos beta
c^2 = a^2 + b^2 - 2ab * cos gama

/** Eratostenovo sito 10^7 + isPrime(10digit) **/

#include <bitset> // compact STL for
ll _sieve_size; // ll is defined as:
bitset<10000010> bs; // 10^7 + small
vi primes; // compact list of primes

typedef long long ll;

void sieve(ll upperbound) { // create list of primes in [0 .. upperbound]
    _sieve_size = upperbound + 1; // add 1 to include upperbound
    bs.reset(); bs.flip(); // set all numbers to 1
    bs.set(0, false); bs.set(1, false); // except index 0 and 1
    for (ll i = 2; i <= _sieve_size; i++) if (bs.test((size_t)i)) {
    // cross out multiples of i starting from i * i!
    for (ll j = i * i; j <= _sieve_size; j += i) bs.set((size_t)j, false);
    primes.push_back((int)i); // also add this vector containing list of primes
    }
} // call this method in main method

bool isPrime(ll N) { // a good enough deterministic prime tester
    if (N < _sieve_size) return bs.test(N); // O(1) for small primes
    REP (i, 0, primes.size() - 1) if (N % primes[i] == 0) return false;
    return true; // it takes longer time if N is a large prime!
} // Note: only work for N <= (last prime in vi "primes")^2
// in int main()
sieve(10000000); // can go up to 10^7
printf("%d\n", isPrime(5915587277)); // 10 digit prime

/**Prime factors**/

vi primeFactors(int N) {
    vi factors;
    // vi "primes" (generated by sieve) is optional
    int PF_idx = 0, PF = primes[PF_idx]; // using PF = 2, 3, 4, ..., is also ok.
    while (N != 1 && (PF * PF <= N)) { // stop at sqrt(N), but N can get smaller
        while (N % PF == 0) { N /= PF; factors.push_back(PF); } // remove this PF
        PF = primes[++PF_idx]; // only consider primes!
    }
    if (N != 1) factors.push_back(N); // special case if N is actually a prime
    return factors;
}

// in int main()
sieve(100); // prepare list of primes [0 .. 100]
vi result = primeFactors(10000); // with that, we can factor up to 100^2 = 10000
vi::iterator last = unique(result.begin(), result.end()); // to remove duplicates
for (vi::iterator i = result.begin(); i != last; i++) // output: 2 and 5
    printf("%d\n", *i);


/** GCD LCM**/
int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); }
int lcm(int a, int b) { return (a * (b / gcd(a, b))); } // divide before multiply!
 /** Eulerova fcia**/

 int EulerPhi(int N) {
    vi factors = primeFactors(N);
    vi::iterator new_end = unique(factors.begin(), factors.end()); // get unique
    int result = N;
    for (vi::iterator i = factors.begin(); i != new_end; i++)
    result = result - result / *i;
    return result;
}

